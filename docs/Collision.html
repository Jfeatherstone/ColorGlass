<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>cgc.Collision API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cgc.Collision</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .Wavefunction import Wavefunction

import numpy as np
from scipy.fft import ifft2, fft2


class Collision():

    targetWavefunction = None # Implements wilson line
    incidentWavefunction = None # Doesn&#39;t (have to) implement wilson line

    _omega = None
    _omegaFFT = None
    _particlesProduced = None
    _momentaBins = None

    _omegaExists = False
    _omegaFFTExists = False
    _particlesProducedExists = False
    _momentaBinsExists = False

    def __init__(self, wavefunction1: Wavefunction, wavefunction2: Wavefunction):
        &#34;&#34;&#34;
        Initialize a collision with two wavefunctions, presumably a nucleus and a proton. The first is expected to implement
        the wilson line, though as long as only one of the wavefunctions has this property, it will detect the proper one.

        In the case that both wavefunctions implement the wilson line, the first (wavefunction1) will be used as such.

        In the case that neither implement the wilson line, an exception will be raised.

        Parameters
        ----------
        wavefunction1 : Wavefunction (or child)
            The first wavefunction

        wavefunction2 : Wavefunction (or child)
            The second wavefunction
        &#34;&#34;&#34;

        # Make sure that at least one has a wilson line
        wilsonLineExists1 = callable(getattr(wavefunction1, &#34;wilsonLine&#34;, None))
        wilsonLineExists2 = callable(getattr(wavefunction2, &#34;wilsonLine&#34;, None))

        if not wilsonLineExists1 and not wilsonLineExists2:
            raise Exception(&#34;Neither of the wavefunctions passed to Collision(Wavefunction, Wavefunction) implement the wilsonLine() method; at least one is required to.&#34;)

        if wilsonLineExists1 and not wilsonLineExists2:
            self.targetWavefunction = wavefunction1
            self.incidentWavefunction = wavefunction2
        elif wilsonLineExists2 and not wilsonLineExists1:
            self.targetWavefunction = wavefunction2
            self.incidentWavefunction = wavefunction1
        else:
            self.targetWavefunction = wavefunction1
            self.incidentWavefunction = wavefunction2

        # Make sure that both use the same number of colors
        if self.targetWavefunction.gluonDOF != self.incidentWavefunction.gluonDOF:
            raise Exception(f&#34;Wavefunctions implement different gluon degrees of freedom (number of color charges): {self.incidentWavefunction.gluonDOF} vs. {self.targetWavefunction.gluonDOF}&#34;)

        # Probably some other checks that need to be done to make sure the two wavefunctions are compatable, but this is fine for now

        # Carry over some variables so we don&#39;t have to call through the wavefunctions so much
        self.N = self.targetWavefunction.N
        self.length = self.targetWavefunction.length
        self.gluonDOF = self.targetWavefunction.gluonDOF
        self.delta = self.targetWavefunction.delta
        self.fftNormalization = self.targetWavefunction.fftNormalization
        #print(self.targetWavefunction)
        #print(self.incidentWavefunction)

        
        # Variables to do with binning the momenta later on
        self.binSize = 4*np.pi/self.length
        self.kMax = 1/self.delta
        self.numBins = int(self.kMax/self.binSize)

    def omega(self):
        &#34;&#34;&#34;
        Calculate the field omega at each point on the lattice.

        If the field already exists, it is simply returned and no calculation is done.

        Returns
        -------
        numpy.array : shape=(2, 2, `colorCharges`**2 - 1, N, N)

        &#34;&#34;&#34;

        if self._omegaExists:
            return self._omega

        # 2,2 is for the 2 dimensions, x and y
        self._omega = np.zeros([2, 2, self.gluonDOF, self.N, self.N], dtype=&#39;complex&#39;) # 2 is for two dimensions, x and y

        def x_deriv(matrix, i, j):
            return (matrix[i,(j+1)%self.N] - matrix[i,j-1]) / (2*self.delta)

        def y_deriv(matrix, i, j):
            return (matrix[(i+1)%self.N,j] - matrix[i-1,j]) / (2*self.delta)

        derivs = [x_deriv, y_deriv]

        for i in range(self.N):
            for j in range(self.N):
                for k in range(self.gluonDOF):
                    for l in range(2): # 2 is number of dimensions
                        for n in range(2): # 2 is number of dimensions
                            self._omega[l,n,k,i,j] = np.sum([derivs[l](self.incidentWavefunction.gaugeField()[m], i, j) * derivs[n](self.targetWavefunction.adjointWilsonLine()[k+1, m+1], i, j) for m in range(self.gluonDOF)])

        return self._omega


    def omegaFFT(self):
        &#34;&#34;&#34;
        Compute the fourier transform of the field omega on the lattice.

        If the fft of the field already exists, it is simply returned and no calculation is done.
        &#34;&#34;&#34;
        if self._omegaFFTExists:
            return self._omegaFFT

        # Make sure omega exists
        self.omega()

        self._omegaFFT = fft2(self._omega, axes=(-2, -1), norm=self.fftNormalization)
        self._omegaFFTExists = True

        return self._omegaFFT


    def momentaBins(self):
        &#34;&#34;&#34;
        Compute the range of momenta at which particles will be created based on the dimensions of the lattice.

        If the bins already exist, they are simply returned and no calculation is done.
        &#34;&#34;&#34;

        if self._momentaBinsExists:
            return self._momentaBins

        self._momentaBins = [i*self.binSize for i in range(self.numBins)]
        self._momentaBinsExists = True

        return self._momentaBins

    def particlesProduced(self):
        &#34;&#34;&#34;
        Compute the number of particles produced at each value of momentum in `momentaBins()`.
        
        If the calculation has already been done, the result is simply returned and is not repeated.
        &#34;&#34;&#34;
        if self._particlesProducedExists:
            return self._particlesProduced

        momentaMagSquared = np.zeros([self.N, self.N])

        for i in range(self.N):
            for j in range(self.N):
                momentaMagSquared[i,j] = 4 / self.delta**2 * (np.sin((2*np.pi*i/self.length)*self.delta/2)**2 + np.sin((2*np.pi*j/self.length)*self.delta/2)**2)

        particleProduction = np.zeros([self.N, self.N])

        # Make sure omegaFFT exists
        self.omegaFFT()

        # # 2D Levi-Cevita symbol
        #Matrix Representation
        LCS = np.array([[0,1],[-1,0]])

        # # 2D Delta function
        #Matrix Representation
        KDF = np.array([[1,0],[0,1]])

        for y in range(self.N):
            for x in range(self.N):
                # To prevent any divide by zero errors
                if momentaMagSquared[y,x] == 0:
                    continue

                for i in range(2):
                    for j in range(2):
                        for l in range(2):
                            for m in range(2):

                                for a in range(self.gluonDOF):
                                    particleProduction[y,x] += np.real(2/(2*np.pi)**3 / momentaMagSquared[y,x] * (KDF[i,j]*KDF[l,m] + LCS[i,j]*LCS[l,m]) * self._omegaFFT[i,j,a,y,x] * np.conj(self._omegaFFT[l,m,a,y,x]))

        vectorizedParticles = np.reshape(particleProduction, [self.N*self.N])
        vectorizedMomentaMagSquared = np.reshape(np.sqrt(momentaMagSquared), [self.N*self.N])

        self._particlesProduced = np.zeros(self.numBins)
        self.momentaBins()

        # Note the use of element-wise (or bitwise) and, &#34;&amp;&#34;
        for i in range(self.numBins):
            self._particlesProduced[i] = np.mean(vectorizedParticles[(vectorizedMomentaMagSquared &lt; self.binSize*(i+1)) &amp; (vectorizedMomentaMagSquared &gt; self.binSize*i)])

        self._particlesProducedExists = True

        return self._particlesProduced</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cgc.Collision.Collision"><code class="flex name class">
<span>class <span class="ident">Collision</span></span>
<span>(</span><span>wavefunction1: <a title="cgc.Wavefunction.Wavefunction" href="Wavefunction.html#cgc.Wavefunction.Wavefunction">Wavefunction</a>, wavefunction2: <a title="cgc.Wavefunction.Wavefunction" href="Wavefunction.html#cgc.Wavefunction.Wavefunction">Wavefunction</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a collision with two wavefunctions, presumably a nucleus and a proton. The first is expected to implement
the wilson line, though as long as only one of the wavefunctions has this property, it will detect the proper one.</p>
<p>In the case that both wavefunctions implement the wilson line, the first (wavefunction1) will be used as such.</p>
<p>In the case that neither implement the wilson line, an exception will be raised.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wavefunction1</code></strong> :&ensp;<code>Wavefunction (or child)</code></dt>
<dd>The first wavefunction</dd>
<dt><strong><code>wavefunction2</code></strong> :&ensp;<code>Wavefunction (or child)</code></dt>
<dd>The second wavefunction</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Collision():

    targetWavefunction = None # Implements wilson line
    incidentWavefunction = None # Doesn&#39;t (have to) implement wilson line

    _omega = None
    _omegaFFT = None
    _particlesProduced = None
    _momentaBins = None

    _omegaExists = False
    _omegaFFTExists = False
    _particlesProducedExists = False
    _momentaBinsExists = False

    def __init__(self, wavefunction1: Wavefunction, wavefunction2: Wavefunction):
        &#34;&#34;&#34;
        Initialize a collision with two wavefunctions, presumably a nucleus and a proton. The first is expected to implement
        the wilson line, though as long as only one of the wavefunctions has this property, it will detect the proper one.

        In the case that both wavefunctions implement the wilson line, the first (wavefunction1) will be used as such.

        In the case that neither implement the wilson line, an exception will be raised.

        Parameters
        ----------
        wavefunction1 : Wavefunction (or child)
            The first wavefunction

        wavefunction2 : Wavefunction (or child)
            The second wavefunction
        &#34;&#34;&#34;

        # Make sure that at least one has a wilson line
        wilsonLineExists1 = callable(getattr(wavefunction1, &#34;wilsonLine&#34;, None))
        wilsonLineExists2 = callable(getattr(wavefunction2, &#34;wilsonLine&#34;, None))

        if not wilsonLineExists1 and not wilsonLineExists2:
            raise Exception(&#34;Neither of the wavefunctions passed to Collision(Wavefunction, Wavefunction) implement the wilsonLine() method; at least one is required to.&#34;)

        if wilsonLineExists1 and not wilsonLineExists2:
            self.targetWavefunction = wavefunction1
            self.incidentWavefunction = wavefunction2
        elif wilsonLineExists2 and not wilsonLineExists1:
            self.targetWavefunction = wavefunction2
            self.incidentWavefunction = wavefunction1
        else:
            self.targetWavefunction = wavefunction1
            self.incidentWavefunction = wavefunction2

        # Make sure that both use the same number of colors
        if self.targetWavefunction.gluonDOF != self.incidentWavefunction.gluonDOF:
            raise Exception(f&#34;Wavefunctions implement different gluon degrees of freedom (number of color charges): {self.incidentWavefunction.gluonDOF} vs. {self.targetWavefunction.gluonDOF}&#34;)

        # Probably some other checks that need to be done to make sure the two wavefunctions are compatable, but this is fine for now

        # Carry over some variables so we don&#39;t have to call through the wavefunctions so much
        self.N = self.targetWavefunction.N
        self.length = self.targetWavefunction.length
        self.gluonDOF = self.targetWavefunction.gluonDOF
        self.delta = self.targetWavefunction.delta
        self.fftNormalization = self.targetWavefunction.fftNormalization
        #print(self.targetWavefunction)
        #print(self.incidentWavefunction)

        
        # Variables to do with binning the momenta later on
        self.binSize = 4*np.pi/self.length
        self.kMax = 1/self.delta
        self.numBins = int(self.kMax/self.binSize)

    def omega(self):
        &#34;&#34;&#34;
        Calculate the field omega at each point on the lattice.

        If the field already exists, it is simply returned and no calculation is done.

        Returns
        -------
        numpy.array : shape=(2, 2, `colorCharges`**2 - 1, N, N)

        &#34;&#34;&#34;

        if self._omegaExists:
            return self._omega

        # 2,2 is for the 2 dimensions, x and y
        self._omega = np.zeros([2, 2, self.gluonDOF, self.N, self.N], dtype=&#39;complex&#39;) # 2 is for two dimensions, x and y

        def x_deriv(matrix, i, j):
            return (matrix[i,(j+1)%self.N] - matrix[i,j-1]) / (2*self.delta)

        def y_deriv(matrix, i, j):
            return (matrix[(i+1)%self.N,j] - matrix[i-1,j]) / (2*self.delta)

        derivs = [x_deriv, y_deriv]

        for i in range(self.N):
            for j in range(self.N):
                for k in range(self.gluonDOF):
                    for l in range(2): # 2 is number of dimensions
                        for n in range(2): # 2 is number of dimensions
                            self._omega[l,n,k,i,j] = np.sum([derivs[l](self.incidentWavefunction.gaugeField()[m], i, j) * derivs[n](self.targetWavefunction.adjointWilsonLine()[k+1, m+1], i, j) for m in range(self.gluonDOF)])

        return self._omega


    def omegaFFT(self):
        &#34;&#34;&#34;
        Compute the fourier transform of the field omega on the lattice.

        If the fft of the field already exists, it is simply returned and no calculation is done.
        &#34;&#34;&#34;
        if self._omegaFFTExists:
            return self._omegaFFT

        # Make sure omega exists
        self.omega()

        self._omegaFFT = fft2(self._omega, axes=(-2, -1), norm=self.fftNormalization)
        self._omegaFFTExists = True

        return self._omegaFFT


    def momentaBins(self):
        &#34;&#34;&#34;
        Compute the range of momenta at which particles will be created based on the dimensions of the lattice.

        If the bins already exist, they are simply returned and no calculation is done.
        &#34;&#34;&#34;

        if self._momentaBinsExists:
            return self._momentaBins

        self._momentaBins = [i*self.binSize for i in range(self.numBins)]
        self._momentaBinsExists = True

        return self._momentaBins

    def particlesProduced(self):
        &#34;&#34;&#34;
        Compute the number of particles produced at each value of momentum in `momentaBins()`.
        
        If the calculation has already been done, the result is simply returned and is not repeated.
        &#34;&#34;&#34;
        if self._particlesProducedExists:
            return self._particlesProduced

        momentaMagSquared = np.zeros([self.N, self.N])

        for i in range(self.N):
            for j in range(self.N):
                momentaMagSquared[i,j] = 4 / self.delta**2 * (np.sin((2*np.pi*i/self.length)*self.delta/2)**2 + np.sin((2*np.pi*j/self.length)*self.delta/2)**2)

        particleProduction = np.zeros([self.N, self.N])

        # Make sure omegaFFT exists
        self.omegaFFT()

        # # 2D Levi-Cevita symbol
        #Matrix Representation
        LCS = np.array([[0,1],[-1,0]])

        # # 2D Delta function
        #Matrix Representation
        KDF = np.array([[1,0],[0,1]])

        for y in range(self.N):
            for x in range(self.N):
                # To prevent any divide by zero errors
                if momentaMagSquared[y,x] == 0:
                    continue

                for i in range(2):
                    for j in range(2):
                        for l in range(2):
                            for m in range(2):

                                for a in range(self.gluonDOF):
                                    particleProduction[y,x] += np.real(2/(2*np.pi)**3 / momentaMagSquared[y,x] * (KDF[i,j]*KDF[l,m] + LCS[i,j]*LCS[l,m]) * self._omegaFFT[i,j,a,y,x] * np.conj(self._omegaFFT[l,m,a,y,x]))

        vectorizedParticles = np.reshape(particleProduction, [self.N*self.N])
        vectorizedMomentaMagSquared = np.reshape(np.sqrt(momentaMagSquared), [self.N*self.N])

        self._particlesProduced = np.zeros(self.numBins)
        self.momentaBins()

        # Note the use of element-wise (or bitwise) and, &#34;&amp;&#34;
        for i in range(self.numBins):
            self._particlesProduced[i] = np.mean(vectorizedParticles[(vectorizedMomentaMagSquared &lt; self.binSize*(i+1)) &amp; (vectorizedMomentaMagSquared &gt; self.binSize*i)])

        self._particlesProducedExists = True

        return self._particlesProduced</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="cgc.Collision.Collision.incidentWavefunction"><code class="name">var <span class="ident">incidentWavefunction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cgc.Collision.Collision.targetWavefunction"><code class="name">var <span class="ident">targetWavefunction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cgc.Collision.Collision.momentaBins"><code class="name flex">
<span>def <span class="ident">momentaBins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the range of momenta at which particles will be created based on the dimensions of the lattice.</p>
<p>If the bins already exist, they are simply returned and no calculation is done.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def momentaBins(self):
    &#34;&#34;&#34;
    Compute the range of momenta at which particles will be created based on the dimensions of the lattice.

    If the bins already exist, they are simply returned and no calculation is done.
    &#34;&#34;&#34;

    if self._momentaBinsExists:
        return self._momentaBins

    self._momentaBins = [i*self.binSize for i in range(self.numBins)]
    self._momentaBinsExists = True

    return self._momentaBins</code></pre>
</details>
</dd>
<dt id="cgc.Collision.Collision.omega"><code class="name flex">
<span>def <span class="ident">omega</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the field omega at each point on the lattice.</p>
<p>If the field already exists, it is simply returned and no calculation is done.</p>
<h2 id="returns">Returns</h2>
<p>numpy.array : shape=(2, 2, <code>colorCharges</code>**2 - 1, N, N)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def omega(self):
    &#34;&#34;&#34;
    Calculate the field omega at each point on the lattice.

    If the field already exists, it is simply returned and no calculation is done.

    Returns
    -------
    numpy.array : shape=(2, 2, `colorCharges`**2 - 1, N, N)

    &#34;&#34;&#34;

    if self._omegaExists:
        return self._omega

    # 2,2 is for the 2 dimensions, x and y
    self._omega = np.zeros([2, 2, self.gluonDOF, self.N, self.N], dtype=&#39;complex&#39;) # 2 is for two dimensions, x and y

    def x_deriv(matrix, i, j):
        return (matrix[i,(j+1)%self.N] - matrix[i,j-1]) / (2*self.delta)

    def y_deriv(matrix, i, j):
        return (matrix[(i+1)%self.N,j] - matrix[i-1,j]) / (2*self.delta)

    derivs = [x_deriv, y_deriv]

    for i in range(self.N):
        for j in range(self.N):
            for k in range(self.gluonDOF):
                for l in range(2): # 2 is number of dimensions
                    for n in range(2): # 2 is number of dimensions
                        self._omega[l,n,k,i,j] = np.sum([derivs[l](self.incidentWavefunction.gaugeField()[m], i, j) * derivs[n](self.targetWavefunction.adjointWilsonLine()[k+1, m+1], i, j) for m in range(self.gluonDOF)])

    return self._omega</code></pre>
</details>
</dd>
<dt id="cgc.Collision.Collision.omegaFFT"><code class="name flex">
<span>def <span class="ident">omegaFFT</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the fourier transform of the field omega on the lattice.</p>
<p>If the fft of the field already exists, it is simply returned and no calculation is done.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def omegaFFT(self):
    &#34;&#34;&#34;
    Compute the fourier transform of the field omega on the lattice.

    If the fft of the field already exists, it is simply returned and no calculation is done.
    &#34;&#34;&#34;
    if self._omegaFFTExists:
        return self._omegaFFT

    # Make sure omega exists
    self.omega()

    self._omegaFFT = fft2(self._omega, axes=(-2, -1), norm=self.fftNormalization)
    self._omegaFFTExists = True

    return self._omegaFFT</code></pre>
</details>
</dd>
<dt id="cgc.Collision.Collision.particlesProduced"><code class="name flex">
<span>def <span class="ident">particlesProduced</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the number of particles produced at each value of momentum in <code>momentaBins()</code>.</p>
<p>If the calculation has already been done, the result is simply returned and is not repeated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def particlesProduced(self):
    &#34;&#34;&#34;
    Compute the number of particles produced at each value of momentum in `momentaBins()`.
    
    If the calculation has already been done, the result is simply returned and is not repeated.
    &#34;&#34;&#34;
    if self._particlesProducedExists:
        return self._particlesProduced

    momentaMagSquared = np.zeros([self.N, self.N])

    for i in range(self.N):
        for j in range(self.N):
            momentaMagSquared[i,j] = 4 / self.delta**2 * (np.sin((2*np.pi*i/self.length)*self.delta/2)**2 + np.sin((2*np.pi*j/self.length)*self.delta/2)**2)

    particleProduction = np.zeros([self.N, self.N])

    # Make sure omegaFFT exists
    self.omegaFFT()

    # # 2D Levi-Cevita symbol
    #Matrix Representation
    LCS = np.array([[0,1],[-1,0]])

    # # 2D Delta function
    #Matrix Representation
    KDF = np.array([[1,0],[0,1]])

    for y in range(self.N):
        for x in range(self.N):
            # To prevent any divide by zero errors
            if momentaMagSquared[y,x] == 0:
                continue

            for i in range(2):
                for j in range(2):
                    for l in range(2):
                        for m in range(2):

                            for a in range(self.gluonDOF):
                                particleProduction[y,x] += np.real(2/(2*np.pi)**3 / momentaMagSquared[y,x] * (KDF[i,j]*KDF[l,m] + LCS[i,j]*LCS[l,m]) * self._omegaFFT[i,j,a,y,x] * np.conj(self._omegaFFT[l,m,a,y,x]))

    vectorizedParticles = np.reshape(particleProduction, [self.N*self.N])
    vectorizedMomentaMagSquared = np.reshape(np.sqrt(momentaMagSquared), [self.N*self.N])

    self._particlesProduced = np.zeros(self.numBins)
    self.momentaBins()

    # Note the use of element-wise (or bitwise) and, &#34;&amp;&#34;
    for i in range(self.numBins):
        self._particlesProduced[i] = np.mean(vectorizedParticles[(vectorizedMomentaMagSquared &lt; self.binSize*(i+1)) &amp; (vectorizedMomentaMagSquared &gt; self.binSize*i)])

    self._particlesProducedExists = True

    return self._particlesProduced</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cgc" href="index.html">cgc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cgc.Collision.Collision" href="#cgc.Collision.Collision">Collision</a></code></h4>
<ul class="">
<li><code><a title="cgc.Collision.Collision.incidentWavefunction" href="#cgc.Collision.Collision.incidentWavefunction">incidentWavefunction</a></code></li>
<li><code><a title="cgc.Collision.Collision.momentaBins" href="#cgc.Collision.Collision.momentaBins">momentaBins</a></code></li>
<li><code><a title="cgc.Collision.Collision.omega" href="#cgc.Collision.Collision.omega">omega</a></code></li>
<li><code><a title="cgc.Collision.Collision.omegaFFT" href="#cgc.Collision.Collision.omegaFFT">omegaFFT</a></code></li>
<li><code><a title="cgc.Collision.Collision.particlesProduced" href="#cgc.Collision.Collision.particlesProduced">particlesProduced</a></code></li>
<li><code><a title="cgc.Collision.Collision.targetWavefunction" href="#cgc.Collision.Collision.targetWavefunction">targetWavefunction</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>